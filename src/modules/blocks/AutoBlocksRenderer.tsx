import * as React from 'react';
import type { Diff as TextDiff } from '@sanity/diff-match-patch';

import type { SxProps } from '@mui/joy/styles/types';
import { Button, Typography } from '@mui/joy';
import ExpandLessIcon from '@mui/icons-material/ExpandLess';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';

import type { DMessageRole } from '~/common/stores/chat/chat.message';
import { ContentScaling, themeScalingMap } from '~/common/app.theme';

import type { Block, CodeBlock, HtmlBlock, ImageBlock, TextBlock } from './blocks.types';
import { BlocksContainer } from './BlocksContainer';
import { RenderPlainChatText } from '~/modules/blocks/plaintext/RenderPlainChatText';
import { RenderCode, RenderCodeMemo } from './code/RenderCode';
import { RenderMarkdown, RenderMarkdownMemo } from './markdown/RenderMarkdown';
import { RenderTextDiff } from './textdiff/RenderTextDiff';
import { heuristicIsBlockTextHTML, RenderHtmlResponse } from './html/RenderHtmlResponse';
import { heuristicLegacyImageBlocks, heuristicMarkdownImageReferenceBlocks, RenderImageURL } from './image/RenderImageURL';


// How long is the user collapsed message
const USER_COLLAPSED_LINES: number = 7;


function areBlocksEqual(a: Block, b: Block): boolean {
  if (a.type !== b.type)
    return false;

  switch (a.type) {
    case 'codeb':
      return a.blockTitle === (b as CodeBlock).blockTitle && a.blockCode === (b as CodeBlock).blockCode && a.complete === (b as CodeBlock).complete;
    case 'diffb':
      return false; // diff blocks are never equal
    case 'htmlb':
      return a.html === (b as HtmlBlock).html;
    case 'imageb':
      return a.url === (b as ImageBlock).url && a.alt === (b as ImageBlock).alt;
    case 'textb':
      return a.content === (b as TextBlock).content;
  }
}


function parseBlocksFromText(text: string, disableParsing: boolean, forceTextDiffs?: TextDiff[]): Block[] {
  if (disableParsing)
    return [{ type: 'textb', content: text }];

  if (forceTextDiffs && forceTextDiffs.length >= 1)
    return [{ type: 'diffb', textDiffs: forceTextDiffs }];

  // special case: this could be generated by a proxy that returns an HTML page instead of the API response
  if (heuristicIsBlockTextHTML(text))
    return [{ type: 'htmlb', html: text }];

  // special case: markdown image references (e.g. ![alt text](https://example.com/image.png))
  const mdImageBlocks = heuristicMarkdownImageReferenceBlocks(text);
  if (mdImageBlocks)
    return mdImageBlocks;

  // special case: legacy prodia images
  const legacyImageBlocks = heuristicLegacyImageBlocks(text);
  if (legacyImageBlocks)
    return legacyImageBlocks;

  const regexPatterns = {
    // was: \w\x20\\.+-_ for tge filename, but was missing too much
    // REVERTED THIS: was: (`{3,}\n?|$), but was matching backticks within blocks. so now it must end with a newline or stop
    codeBlock: /`{3,}([\S\x20]+)?\n([\s\S]*?)(`{3,}\n?|$)/g,
    htmlCodeBlock: /<!DOCTYPE html>([\s\S]*?)<\/html>/gi,
    svgBlock: /<svg (xmlns|width|viewBox)=([\s\S]*?)<\/svg>/g,
  };

  const blocks: Block[] = [];
  let lastIndex = 0;

  while (true) {

    // find the first match (if any) trying all the regexes
    let match: RegExpExecArray | null = null;
    let matchType: keyof typeof regexPatterns | null = null;
    for (const type in regexPatterns) {
      const regex = regexPatterns[type as keyof typeof regexPatterns];
      regex.lastIndex = lastIndex;
      const currentMatch = regex.exec(text);
      if (currentMatch && (match === null || currentMatch.index < match.index)) {
        match = currentMatch;
        matchType = type as keyof typeof regexPatterns;
      }
    }
    if (match === null)
      break;

    // anything leftover before the match is text
    if (match.index > lastIndex)
      blocks.push({ type: 'textb', content: text.slice(lastIndex, match.index) });

    // add the block
    switch (matchType) {
      case 'codeBlock':
        const blockTitle: string = (match[1] || '').trim();
        // note: we don't trim blockCode to preserve leading spaces, however if the last line is only made of spaces, we trim that
        const blockCode: string = match[2].replace(/\s+$/, '');
        const blockEnd: string = match[3];
        blocks.push({ type: 'codeb', blockTitle, blockCode, complete: blockEnd.startsWith('```') });
        break;

      case 'htmlCodeBlock':
        const html: string = `<!DOCTYPE html>${match[1]}</html>`;
        blocks.push({ type: 'codeb', blockTitle: 'html', blockCode: html, complete: true });
        break;

      case 'svgBlock':
        blocks.push({ type: 'codeb', blockTitle: 'svg', blockCode: match[0], complete: true });
        break;
    }

    // advance the pointer
    lastIndex = match.index + match[0].length;
  }

  // remainder is text
  if (lastIndex < text.length)
    blocks.push({ type: 'textb', content: text.slice(lastIndex) });

  return blocks;
}


type BlocksRendererProps = {
  // required
  text: string;
  fromRole: DMessageRole;

  contentScaling: ContentScaling;
  fitScreen?: boolean;
  showAsDanger?: boolean;
  showAsItalic?: boolean;
  showTopWarning?: string;
  showUnsafeHtml?: boolean;
  specialCodePlain?: boolean;
  specialDiagramMode?: boolean;

  renderTextAsMarkdown: boolean;
  renderTextDiff?: TextDiff[];

  /**
   * optimization: allow memo to all individual blocks except the last one
   * work in progress on that
   */
  optiAllowSubBlocksMemo?: boolean;

  onContextMenu?: (event: React.MouseEvent) => void;
  onDoubleClick?: (event: React.MouseEvent) => void;
};


/**
 * Features: collpase/expand, auto-detects HTML, SVG, Code, etc..
 */
export const AutoBlocksRenderer = React.forwardRef<HTMLDivElement, BlocksRendererProps>((props, ref) => {

  // state
  const [forceUserExpanded, setForceUserExpanded] = React.useState(false);
  const prevBlocksRef = React.useRef<Block[]>([]);

  // derived state
  const { text: _text, renderTextDiff } = props;
  const fromAssistant = props.fromRole === 'assistant';
  const fromSystem = props.fromRole === 'system';
  const fromUser = props.fromRole === 'user';
  const isUserCommand = fromUser && _text.startsWith('/');


  // Memo text, which could be 'collapsed' to a few lines in case of user messages

  const { text, isTextCollapsed } = React.useMemo(() => {
    if (fromUser && !forceUserExpanded) {
      const textLines = _text.split('\n');
      if (textLines.length > USER_COLLAPSED_LINES)
        return { text: textLines.slice(0, USER_COLLAPSED_LINES).join('\n'), isTextCollapsed: true };
    }
    return { text: _text, isTextCollapsed: false };
  }, [forceUserExpanded, fromUser, _text]);

  const handleTextCollapse = React.useCallback(() => {
    setForceUserExpanded(false);
  }, []);

  const handleTextUncollapse = React.useCallback(() => {
    setForceUserExpanded(true);
  }, []);


  // Block splitter, with memo and special recycle of former blocks, to help React minimize render work

  const autoBlocksMemo = React.useMemo(() => {
    // split the complete input text into blocks
    const newBlocks = parseBlocksFromText(text, fromSystem, renderTextDiff);

    // recycle the previous blocks if they are the same, for stable references to React
    const recycledBlocks: Block[] = [];
    for (let i = 0; i < newBlocks.length; i++) {
      const newBlock = newBlocks[i];
      const prevBlock: Block | undefined = prevBlocksRef.current[i];

      // Check if the new block can be replaced by the previous block to maintain reference stability
      if (prevBlock && areBlocksEqual(prevBlock, newBlock)) {
        recycledBlocks.push(prevBlock);
      } else {
        // Once a block doesn't match, we use the new blocks from this point forward.
        recycledBlocks.push(...newBlocks.slice(i));
        break;
      }
    }

    // Update prevBlocksRef with the current blocks for the next render
    prevBlocksRef.current = recycledBlocks;

    // Apply specialDiagramMode filter if applicable
    return props.specialDiagramMode
      ? recycledBlocks.filter(block => block.type === 'codeb' || recycledBlocks.length === 1)
      : recycledBlocks;
  }, [fromSystem, props.specialDiagramMode, renderTextDiff, text]);


  // Memo the styles, to minimize re-renders

  const scaledCodeSx: SxProps = React.useMemo(() => ({
    my: props.specialCodePlain ? 0 : themeScalingMap[props.contentScaling]?.blockCodeMarginY ?? 0,
    backgroundColor: props.specialCodePlain ? 'background.surface' : fromAssistant ? 'neutral.plainHoverBg' : 'primary.plainActiveBg',
    boxShadow: props.specialCodePlain ? undefined : 'inset 2px 0px 5px -4px var(--joy-palette-background-backdrop)', // was 'xs'
    borderRadius: 'sm',
    fontFamily: 'code',
    fontSize: themeScalingMap[props.contentScaling]?.blockCodeFontSize ?? '0.875rem',
    fontWeight: 'md', // JetBrains Mono has a lighter weight, so we need that extra bump
    fontVariantLigatures: 'none',
    lineHeight: themeScalingMap[props.contentScaling]?.blockLineHeight ?? 1.75,
    minWidth: 288,
    minHeight: '2.75rem',
  }), [fromAssistant, props.contentScaling, props.specialCodePlain]);

  const scaledImageSx: SxProps = React.useMemo(() => ({
    fontSize: themeScalingMap[props.contentScaling]?.blockFontSize ?? undefined,
    lineHeight: themeScalingMap[props.contentScaling]?.blockLineHeight ?? 1.75,
    marginBottom: themeScalingMap[props.contentScaling]?.blockImageGap ?? 1.5,
  }), [props.contentScaling]);

  const scaledTypographySx: SxProps = React.useMemo(() => ({
    fontSize: themeScalingMap[props.contentScaling]?.blockFontSize ?? undefined,
    lineHeight: themeScalingMap[props.contentScaling]?.blockLineHeight ?? 1.75,
    ...(props.showAsDanger ? { color: 'danger.500', fontWeight: 500 } : {}),
    ...(props.showAsItalic ? { fontStyle: 'italic' } : {}),
  }), [props.contentScaling, props.showAsDanger, props.showAsItalic]);


  const toggleExpansionButtonSx: SxProps = React.useMemo(() => ({
    width: '100%',
    fontSize: themeScalingMap[props.contentScaling]?.fragmentButtonFontSize ?? undefined,
    borderTopLeftRadius: 0,
    borderTopRightRadius: 0,
    ...(props.specialCodePlain ? {
      // Style when inside the <DocumentFragmentEditor />
      backgroundColor: 'background.surface',
      // marginTop: -0.5,
    } : {
      // Style when inside <ChatMessage /> in particular for 'user' messages
      marginTop: 1,
    }),
  }), [props.contentScaling, props.specialCodePlain]);


  return (
    <BlocksContainer
      ref={ref}
      onContextMenu={props.onContextMenu}
      onDoubleClick={props.onDoubleClick}
    >

      {/* Warn about user-edited system message */}
      {!!props.showTopWarning?.length && (
        <Typography level='body-sm' color='warning' sx={{ mt: 1, mx: 1.5 }}>{props.showTopWarning}</Typography>
      )}

      {/* sequence of render components, for each Block */}
      {autoBlocksMemo.map((block, index) => {
        // Optimization: only memo the non-currently-rendered components, if the message is still in flux
        const optimizeSubBlockWithMemo = props.optiAllowSubBlocksMemo && index !== autoBlocksMemo.length - 1;
        const RenderCodeMemoOrNot = optimizeSubBlockWithMemo ? RenderCodeMemo : RenderCode;
        const RenderMarkdownMemoOrNot = optimizeSubBlockWithMemo ? RenderMarkdownMemo : RenderMarkdown;
        return block.type === 'htmlb' ? <RenderHtmlResponse key={'html-' + index} htmlBlock={block} sx={scaledCodeSx} />
          : block.type === 'codeb' ? <RenderCodeMemoOrNot key={'code-' + index} codeBlock={block} fitScreen={props.fitScreen} initialShowHTML={props.showUnsafeHtml} noCopyButton={props.specialDiagramMode} optimizeLightweight={false /*!optimizeSubBlockWithMemo*/} sx={scaledCodeSx} />
            : block.type === 'imageb' ? <RenderImageURL key={'image-' + index} imageURL={block.url} expandableText={block.alt} onImageRegenerate={undefined /* we'd need to have selective fragment editing as there could be many of these URL images in a fragment */} scaledImageSx={scaledImageSx} variant='content-part' />
              : block.type === 'diffb' ? <RenderTextDiff key={'text-diff-' + index} textDiffBlock={block} sx={scaledTypographySx} />
                : (props.renderTextAsMarkdown && !fromSystem && !isUserCommand)
                  ? <RenderMarkdownMemoOrNot key={'text-md-' + index} textBlock={block} sx={scaledTypographySx} />
                  : <RenderPlainChatText key={'text-' + index} textBlock={block} sx={scaledTypographySx} />;
      })}

      {(isTextCollapsed || forceUserExpanded) && (
        <div style={{ lineHeight: 1 /* Absorbs some weird height issue since the parent has an extended line height (lineHeightChatTextMd) */ }}>
          <Button
            variant='soft'
            color={props.specialCodePlain ? 'neutral' : undefined}
            size='sm'
            onClick={isTextCollapsed ? handleTextUncollapse : handleTextCollapse}
            startDecorator={isTextCollapsed ? <ExpandMoreIcon /> : <ExpandLessIcon />}
            sx={toggleExpansionButtonSx}
          >
            {isTextCollapsed ? 'Show more' : 'Show less'}
          </Button>
        </div>
      )}

      {/* import VisibilityIcon from '@mui/icons-material/Visibility'; */}
      {/*<br />*/}
      {/*<Chip variant='outlined' color='warning' sx={{ mt: 1, fontSize: '0.75em' }} startDecorator={<VisibilityIcon />}>*/}
      {/*  BlockAction*/}
      {/*</Chip>*/}

    </BlocksContainer>
  );
});

AutoBlocksRenderer.displayName = 'AutoBlocksRenderer';
